---
title: "Sequence abundances in community"
author: "Chang-Yu Chang"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: yes
    number_sections: no

---

```{r setup, include = FALSE}
# Knitr options
knitr::opts_chunk$set(cache = TRUE, echo = FALSE)
library(tidyverse)
library(data.table)
# isolates_ID_match <- fread(root$find_file("data/temp/isolates_ID_match.csv"))

```


# Read community sequences

```{r}
source("script/01E-match_community_abundance-01-community_sequence.R")
```

There are two OTU tables and I named them arbitrarily:

1. `communities_abundance`: raw data from Nanxi
2. `communities_abundance_syl`: curated community ESV table from Sylvie


I formated the data.frame so that both of them have the following variables:

- `SampleID`: experiment ID used by Nanxi or Sylvie.
- `Community`: community, for instance, C2R4 or C1Rpool.
- `Transfer`: the transfer when the community was sequenced.
- `Adundance`: the number of this sequence in the community.
- `RelativeAbundance`
- `CommunityESVID`: the sequence identifier. This identifier is community-sequence specific.
- `ESV`: the DNA sequence in 16s V4 region.

In `communities_abundance_syl`, there are other parameters

- `CarbonSource`: the carbon source used for assembly
- `Order`, `Family`, and `Genus`: SILVA assigned taxonomy


```{r echo = T}
communities_abundance 
```


```{r echo = T}
communities_abundance_syl
```


Community richness along transfers based on `communities_abundance`

```{r}
communities_richness %>%
  filter(!is.na(Community)) %>% 
  group_by(Community, Transfer) %>%
  summarize(Richness = mean(Richness)) %>%
  ggplot(aes(col = Community, group = Community)) +
  geom_point(aes(x = Transfer, y = Richness)) +
  geom_line(aes(x = Transfer, y = Richness)) +
  scale_color_discrete() +
#  facet_wrap(Community~., scale = "free_y") +
  theme_bw()
```



# Match community ESVs and isolate Sanger sequences

```{r}
# It may take 10 mins
source("script/01E-match_community_abundance-02-match_isolate_16S.R")
```

IUPAC notation for DNA base pairs

W, S, M, K, R, Y represent two possiblities for one base pair
B, D, H, V represent three possiblitieis
N means any nucleotide (but not a gap)

I tested five alignment methods in `Biostrings::pairwiseAlignment()`

```{r echo = T }
sequences_alignment_syl
```


```{r}
# R function for computing distinct Sanger
distinct_sanger <- function(x, allow_mismatch = 2) {
  x %>%
    # Filter for BasePairMatch
    filter(BasePairMismatch <= allow_mismatch) %>%
    # For each Sanger, find the Sanger-ESV match with highest alignment score
    group_by(AlignmentType, ExpID) %>%
    arrange(desc(AlignmentScore)) %>%
    dplyr::slice(1) %>%
    ungroup() %>%
    # Remove duplicates that matches two Sangers to one ESV
    group_by(AlignmentType, Community, CommunityESVID) %>%
    distinct(RelativeAbundance, .keep_all = T) %>%
    arrange(Community) %>%
    # Specify mismatch allowed
    mutate(AllowMismatch = allow_mismatch) %>%
    group_by(AlignmentType) %>%
    summarize(Count = n())
}

x <- sequences_alignment_syl
# R function for matched isolate Sanger
"
finish this function
"

matched_sanger <- function (x, allow_mismatch = 2) {
  x %>%
     # Filter for BasePairMatch
    filter(BasePairMismatch <= allow_mismatch) %>%
    # For each Sanger, find the Sanger-ESV match with highest alignment score
    group_by(AlignmentType, ExpID) %>%
    arrange(desc(AlignmentScore)) %>%
    dplyr::slice(1) %>%
    ungroup() %>%
    # Remove duplicates that matches two Sangers to one ESV
    group_by(AlignmentType, Community, CommunityESVID) %>%
    distinct(RelativeAbundance, .keep_all = T) %>%
    arrange(Community) %>%
    # Specify mismatch allowed
    mutate(AllowMismatch = allow_mismatch) %>%
    group_by(AlignmentType) %>%
    summarize(Count = n())
}

```

Number of isolates being matched to the community ESV if we allow for up to two mismatches. 

```{r}
distinct_sanger(sequences_alignment_syl, allow_mismatch = 2)
```

Up to one mistmatch

```{r}
distinct_sanger(sequences_alignment_syl, allow_mismatch = 1)
```

No mistmatch

```{r}
distinct_sanger(sequences_alignment_syl, allow_mismatch = 0)
```


# Relative abundance explained by the sequences 

```{r message = F, warning = F}
source("script/01E-match_community_abundance-03-matched_abundance.R")
```


Abundances explained by ESVs

```{r}
plot_abundance <- function(df, label_x = "Community", label_y = "RelativeAbundance", fill = "CommunityESVID") {
  ggplot(df) +
    geom_bar(aes_string(x = label_x, y = label_y, fill = fill),
      position = "stack", stat = "identity", col = 1) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
}

communities_abundance_syl %>%
  filter(CarbonSource == "Glucose") %>%
  plot_abundance(label_x = "Community", label_y = "RelativeAbundance", fill = "Family")
```

Abundances explained by ESVs in 13 communties

```{r}
communities_abundance_syl %>% 
  filter(CarbonSource == "Glucose") %>% 
  filter(Community %in% communities_name) %>%
  plot_abundance(label_x = "Community", label_y = "RelativeAbundance", fill = "Family")
```



```{r}
# This chunck is modified on 20200309 for Sylvie's paper
sequences_abundance <- fread(here::here("data/temp/sequences_abundance.csv"))
#sequences_abundance <- fread(("~/Desktop/Lab/invnet/data/temp/sequences_abundance.csv"))

# Filter for the plot
temp <- sequences_abundance %>%
  filter(AlignmentType == "local") %>%
  filter(AllowMismatch == Inf) %>%
  filter(BasePairMismatch <= 4) %>%
  #mutate(AllowMismatch = paste0("AllowMismatch: ", AllowMismatch))
  {.}

fwrite(temp, "data/01E-match_community_abundance-isolate_abundance.csv")

# Color sets from Sylvie
temp2 <- tibble(Color = c("yellow", "deepskyblue3", "blue", "darkorchid2", "firebrick", "orange2", "grey"),
  Family = c("Aeromonadaceae", "Enterobacteriaceae", "Moraxellaceae", "Pseudomonadaceae","Comamonadaceae","Alcaligenaceae", "Sphingobacteriaceae"))

p_temp <- temp %>%
  mutate(Community = ordered(Community,  communities_name)) %>%
  plot_abundance(label_x = "Community", label_y = " RelativeAbundance", fill = "Family") +
  labs(x = "", y = "Relative abundance") +
  scale_fill_manual(values = setNames(temp2$Color, temp2$Family)) +
  scale_x_discrete(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0), limits = c(0,1), breaks = seq(0,1, .25)) + 
  NULL

p_temp 

ggsave("figure/01E-match_community_abundance-isolate_abundance.pdf", p_temp, width = 6, height = 4)
```


Abundance explained by isolate sequences. Rows are different alignment algorithms used by `Biostring::pairwiseAlignment()`, whereas columns are how many bp mismatches are allowed in ESV-Sanger matches. 

```{r fig.width=4, fig.height=4}
sequences_abundance %>%
  mutate(AllowMismatch = paste0("AllowMismatch: ", AllowMismatch)) %>%
  plot_abundance(label_x = "Community", label_y = "RelativeAbundance", fill = "Family") +
  facet_grid(AllowMismatch~AlignmentType) +
  theme(legend.position = "top")
```







