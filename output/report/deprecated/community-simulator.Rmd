---
title: "Community Simulator"
author: "Chang-Yu Chang"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: yes
  pdf_document:
    toc: yes
  bookdown::pdf_document2:
    number_sections: no
    toc: no
linkcolor: red
fontsize: 12pt
urlcolor: blue
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  cache = TRUE, 
  echo = TRUE,
	fig.align = "center",
	fig.height = 4,
	fig.width = 6)
#  engine.path = '~/anaconda3/bin/python3.7m')
library(tidyverse)
library(data.table)
library(reticulate) # Python interface
reticulate::use_python('~/anaconda3/bin/python3.7')
#library(invnet)
root <- rprojroot::is_r_package
```

# Setting 

## Installation

Python version for running python on R.

```{python}
import sys
print(sys.version)
```

Install community package locally.

1. Download the python package locally (to your laptop) from [GitHub community-simulator](https://github.com/Emergent-Behaviors-in-Biology/community-simulator).  

2. Run the following code in bash

```{bash eval = F}
cd ~/Desktop/Lab/community-simulator
pip install -e .
```

## Import packages

```{python}
from IPython.display import Image
from community_simulator import *
from community_simulator.usertools import *
from community_simulator.visualization import *
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.backends import backend_pdf as bpdf
colors = sns.color_palette()
#%matplotlib inline
```

# Simple examples

## Tutorial example 

Initial conditions

```{python}
assumptions=a_default.copy() #Start with default parameters
assumptions['n_wells'] = 100 #Add more wells
assumptions['l'] = 0.8 #Assign a high leakage fraction to allow for a lot of crossfeeding
R0_food = np.linspace(30,300,assumptions['n_wells']) #Make a gradient of food supply levels
assumptions['R0_food'] = R0_food

#Make initial state
init_state = MakeInitialState(assumptions)

#Make dynamics
def dNdt(N,R,params):
    return MakeConsumerDynamics(assumptions)(N,R,params)
def dRdt(N,R,params):
    return MakeResourceDynamics(assumptions)(N,R,params)
dynamics = [dNdt,dRdt]

#Make parameters
params = MakeParams(assumptions)

#Initialize plate
#(parallel=False ensures that tutorial will run on Windows.
#If you are running on Mac or Linux, set parallel=True to speed up)
plate1 = Community(init_state,dynamics,params,parallel=True)
```


Run the steady state algorithm.

```{python eval = F}
#Find steady state
plate1.SteadyState()
```

Plot the result by community-simulator ploting functions.

```{python}
#Plot community compositions
fig,ax=plt.subplots()
StackPlot(plate1.N,ax=ax)
ax.set_xlabel('Well',fontsize=14)
ax.set_ylabel('Species Abundance',fontsize=14)
plt.show()

#Make histogram of all population sizes
fig,ax=plt.subplots()
np.log10(plate1.N+1e-20).plot.hist(ax=ax,bins=30,legend=False)
ax.set_xlim((-12,4))
ax.set_xlabel('log10 Species Abundance')
plt.show()

#Plot diversity
fig,ax=plt.subplots()
ax.scatter(R0_food,(plate1.N>1e-4).sum().values)
ax.set_xlabel('Food Supply Level',fontsize=14)
ax.set_ylabel('Diversity',fontsize=14)
plt.show()
```


## Single batch

Singel batch, single well. Initiate a plate with 1 community.


```{python}
assumptions=a_default.copy() #Start with default parameters
assumptions.update({"n_wells": 1,  #Add more wells
                    "l": 0.8}) #Assign a high leakage fraction to allow for a lot of crossfeeding
assumptions["R0_food"]= np.linspace(30, 100, assumptions['n_wells'])

#Make initial state
init_state = MakeInitialState(assumptions)

#Make dynamics
def dNdt(N,R,params):
    return MakeConsumerDynamics(assumptions)(N,R,params)
def dRdt(N,R,params):
    return MakeResourceDynamics(assumptions)(N,R,params)
dynamics = [dNdt,dRdt]

#Make parameters
params = MakeParams(assumptions)

#Initialize plate
plate1 = Community(init_state,dynamics,params,parallel=True)
```

Run one propagation

```{python}
N_traj = TimeStamp(plate1.N, 0)
R_traj = TimeStamp(plate1.R, 0)

for i in range(0,48):
    plate1.Propagate(1)
    N_traj = N_traj.append(TimeStamp(plate1.N,i+1))
    R_traj = R_traj.append(TimeStamp(plate1.R,i+1))
```

Plot the dynamics

```{r include = F}
py$N_traj %>%
  as.tibble() %>%
  mutate(Time = 1:nrow(.)) %>%
  tidyr::gather(key = "Resource", value = "Value", 1:(sum(py$assumptions$MA))) %>%
  ggplot(aes(x = Time, y = Value, color = Resource)) +
  geom_line() +
  guides(color = FALSE) +
  theme_minimal()
```

# Initial species pools

Initial states

```{python}
import random
random.seed(10) # Set seeds
assumptions = a_default.copy()
assumptions.update({'sampling':'Binary', #{'Gaussian','Binary','Gamma'} specifies choice of sampling algorithm
          'SA': 10*np.ones(3), #Number of species in each family; you need more species than number of sp in well
          'MA': 10*np.ones(3), #Number of resources of each type
          'Sgen': 5, #Number of generalist species
          'muc': 10, #Mean sum of consumption rates
          'sigc': 3, #Standard deviation of sum of consumption rates for Gaussian and Gamma models
          'q': 0.0, #Preference strength (0 for generalist and 1 for specialist)
          'c0':0.0, #Sum of background consumption rates in binary model
          'c1':1., #Specific consumption rate in binary model
          'l':0.8, #Leakage fraction
          'fs':0.45, #Fraction of secretion flux with same resource type
          'fw':0.45, #Fraction of secretion flux to 'waste' resource
          'sparsity':0.2, #Effective sparsity of metabolic matrix
          'n_wells':10, #Number of independent wells
          'S':10, #Number of species per well
          'food':1, #index of supplied food source
          'R0_food':10, #unperturbed fixed point for supplied food
          'regulation':'independent', #metabolic regulation (see dRdt)
          'response':'type I', #functional response (see dRdt)
          'supply':'off' #resource supply (see dRdt)
         })

init_state = MakeInitialState(assumptions)
#print(init_state[0])
#print(init_state[1])
```


Two algorithms that each of them:

1. Creates a regional species pool
2. Samples communities from regional species pool

```{python}
exec(open("script/community_simulator-01-regional_pool.py").read())
```

```{python eval = F}
# Example
pool = RegionalSpeciesPool(assumptions)  
plate1.N = SampleFromPool(plate1, pool)
```


# Community function


## Coded functions 

This set of functions measures the community phenope from the `Community` object (plate) defined in `community-simulator`.

```{python}
exec(open("script/community_simulator-02-community_function.py").read())
```

Community function algorithms take plate as input and output a 1D array of community phenotype values.

```{python eval = F}
# Additive community function. Assign additive neutral traits to each of species
additive_community_function(plate) 

# Distance to ideal resource compositions
resource_distance_community_function(plate) 
```


## Farmer E coli (unfinished)

```{python}
exec(open("script/community_simulator-02-community_function.py").read())
```

- Define a function that feed plate1.R to a plate that has only one species. The well number is the same

- The function takes arguments: plate1.R, time of propagation, and return a sequence of farmer growth, like what community_function returns

```{python include = F}
np.random.seed(0) #you are all going to get the same species pool
n = 96 #No of wells
assumptions=a_default.copy() #Start with default parameters
assumptions.update({'n_wells':n, # To start only 1 community
                    'c1' :.01,
                    'muc':0.1, #This is just a rescaling of the uptake rate
                    'm':0}) #switch off mortality to make things simpler
init_state = MakeInitialState(assumptions)
params = MakeParams(assumptions)
species_pool = RegionalSpeciesPool(assumptions) # Generate a species pool

# Make plate
np.random.seed(0) # Change to a unique number so that you each start the experiment with a slightly different species pool
plate1 = Community(init_state,dynamics,params,scale = 10**6,parallel=True) # Reset the community
plate1.N = SampleFromPool(plate1.N,species_pool)# Populate the well by sampling from the species pool


# Propagate for 20 passages
function_df = list()
for i in range(0,20):
    plate1.Propagate(48)
    community_function = farmer_community_function(plate1)
    t = select_best_n(community_function, n_select=0.25)
    plate1.Passage(t*1/125)
    function_df.append(community_function)
    print(i)
```


# Community without selection; control

Record community function as a function of time in single community

```{python}
# Set up
np.random.seed(0) #you are all going to get the same species pool
n = 12 #No of wells
assumptions=a_default.copy() #Start with default parameters
assumptions.update({'n_wells':n, # To start only 1 community
                    'c1' :.01,
                    'muc':0.1, #This is just a rescaling of the uptake rate
                    'm':0}) #switch off mortality to make things simpler
init_state = MakeInitialState(assumptions)
params = MakeParams(assumptions)
species_pool = RegionalSpeciesPool(assumptions) # Generate a species pool

# Make plate
np.random.seed(0) # Change to a unique number so that you each start the experiment with a slightly different species pool
plate1 = Community(init_state,dynamics,params,scale = 10**6,parallel=True) # Reset the community
plate1.N = SampleFromPool(plate1.N,species_pool)# Populate the well by sampling from the species pool

#Propagate for 20 passage each lasting '48hr' and record community function every passage
function_df = list()
for i in range(0,20):
    plate1.Propagate(48)
    community_function = additive_community_function(plate1)
    plate1.Passage(np.eye(n)*1/1000)
    function_df.append(community_function)

# Plot the community function as a function of time 
plot_community_function(function_df)
```

# Community selection

```{python}
exec(open("script/community_simulator-03-community_selection.py").read())
```

Community function measurement error = 0.001

```{python}
# Set up
np.random.seed(0) #you are all going to get the same species pool
n = 96 #No of wells
assumptions=a_default.copy() #Start with default parameters
assumptions.update({'n_wells':n, # To start only 1 community
                    'c1' :.01,
                    'muc':0.1, #This is just a rescaling of the uptake rate
                    'm':0}) #switch off mortality to make things simpler
init_state = MakeInitialState(assumptions)
params = MakeParams(assumptions)
species_pool = RegionalSpeciesPool(assumptions) # Generate a species pool

# Make plate
np.random.seed(0) # Change to a unique number so that you each start the experiment with a slightly different species pool
plate1 = Community(init_state,dynamics,params,scale = 10**6,parallel=True) # Reset the community
plate1.N = SampleFromPool(plate1.N,species_pool)# Populate the well by sampling from the species pool


#Propagate for 20 passage each lasting '48hr' and record community function every passage
function_df = list()
for i in range(0,10):
    plate1.Propagate(24)
    community_function = additive_community_function(plate1)
    t = select_best_n(community_function, n_select=0.25)
    plate1.Passage(t*1/1000)
    function_df.append(community_function)
```

## Community selection with higher measurement error

The simulation is put into one single function `simulate_community_function_error`.

Community function measurement error = 0.01

```{python echo = F}
plate1, function_df = simulate_community_function_error(measurement_error_sigma=0.01)
plot_community_function(function_df)
```


Community function measurement error = 0.1

```{python echo = F}
plate1, function_df = simulate_community_function_error(measurement_error_sigma=0.1)
plot_community_function(function_df)
```




# Migration

Migration algorithms that:

1. Generate a migration_factor that determines whether the well is migrated.

2. Migrate from species pool to the current plate

```{python}
exec(open("script/community_simulator-04-migration.py").read())
```


```{python}
# Generate a 1D array that determine whether migration happens in the commnity or not.
migration_factor = migration_factor_from_function(community_function, migration_type = "random")

# Migrate from species pool
migrate_from_pool(plate, species_pool, migration_factor)
```

# Diversity index

```{python}
exec(open("script/community_simulator-05-diversity_index.py").read())
```


```{python eval = F}
Shannon(plate1.N)
Richness(plate1.N)
```


# Record community transfer

```{python}
# Algorithms for simulating community 
n = 96
n_propagation = 2
dilution=1/1000
replicate_index = 2
write_composition = True

phenotype_algorithm = "additive_community_function"
selection_algorithm = "select_best_n"
migration_algorithm = "no_migration"

#
np.random.seed(0) #you are all going to get the same species pool
assumptions=a_default.copy() #Start with default parameters
assumptions.update({'n_wells':n, 'c1' :.01, 'muc':0.1, 'm':0})  # default setting
init_state = MakeInitialState(assumptions)
params = MakeParams(assumptions)
species_pool = RegionalSpeciesPool(assumptions) # Generate a species pool

# Make plate
np.random.seed(replicate_index) 
plate1 = Community(init_state,dynamics,params,scale = 10**6,parallel=True) # Reset the community
plate1.N = SampleFromPool(plate1.N,species_pool) # Populate the well by sampling from the species pool

# Propagate communities
function_df = list()
transfer_df = list()
plate_N_df = list()

for k in range(n_propagation):
    # Propagation
    plate1.Propagate(12)
    plate_N_df.append(plate1.N)
    
    if write_composition == True:
        #plate1.N.to_csv("data/" + "{:02d}".format(phenotype_algorithmID) + "-" + phenotype_algorithm + "-" +"{:02d}".format(selection_algorithmID) + "-" + selection_algorithm + "-" +"{:02d}".format(migration_algorithmID) + "-" + migration_algorithm + "-" + "{:02d}".format(rr) + "-T" + "{:02d}".format(k) + ".csv", index=False)
        print("data/" + "{:02d}".format(phenotype_algorithmID) + "-" + phenotype_algorithm + "-" +"{:02d}".format(selection_algorithmID) + "-" + selection_algorithm + "-" +"{:02d}".format(migration_algorithmID) + "-" + migration_algorithm + "-" + "{:02d}".format(rr) + "-T" + "{:02d}".format(k) + ".csv")

    # Community phenotype
    community_function = globals()[phenotype_algorithm](plate1)
    function_df.append(community_function)
    
    # Passage and tranfer matrix
    if selection_algorithm in ["exponealing", "exponealing2"]: # Propagation time dependent function
        t = globals()[selection_algorithm](community_function, k)
    else:
        t = globals()[selection_algorithm](community_function)
    
    plate1.Passage(t*dilution)
    transfer_df.append(t)
    
    # Migration
    m = globals()[migration_algorithm](community_function) 
    plate1.N = migrate_from_pool(plate1, species_pool, m)
    
    # Print the propagation progress
    print("propagation: " + str(k)) 
    
```



```{python}
pd.DataFrame(function_df)

#plot_transfer_matrix(transfer_df[0])
#plot_transfer_matrix(transfer_df[1])

df = pd.DataFrame(transfer_df[0])
#pd.melt(df, var_name="Col", value_name = "T")

```


















