---
title: "Community selection"
author: "Chang-Yu Chang"
date: "`r Sys.Date()`"
output:
  html_notebook:
    number_sections: no
    toc: yes
linkcolor: red
fontsize: 12pt
urlcolor: blue
---

```{r setup, include = FALSE}
# Knitr options
knitr::opts_chunk$set(
  cache = FALSE, 
  echo = FALSE,
	fig.align = "center",
	fig.height = 3,
	fig.width = 3)

# Packages
library(tidyverse)
library(data.table)
library(invnet)
library(reticulate) # Python interface
reticulate::use_python('~/anaconda3/bin/python3.7m') # Use this python version

# Local directory and functions
root <- rprojroot::is_r_package # Package root
source(root$find_file("misc/utils.R"))
source(root$find_file("misc/network_functions.R"))
write_all_csv <- TRUE
write_all_pdf <- TRUE

# Data
isolates <- fread(root$find_file("data/output/isolates.csv"))
pairs <- fread(root$find_file("data/output/pairs.csv"))
communities <- fread(root$find_file("data/temp/communities.csv"))
communities_name <- communities$Community
communities_size <- communities$CommunitySize
communities_name_pool <- c(paste0("C", 1:12, "Rpool"), paste0("C", rep(1:12, each = 8), "R", rep(1:8, 12)))
```

```{python}
import sys
print(sys.version)
```

# Settings

## Import packages

```{python echo = T}
from IPython.display import Image
from community_simulator import *
from community_simulator.usertools import *
from community_simulator.visualization import *
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.backends import backend_pdf as bpdf
#colors = sns.color_palette()
#%matplotlib inline
```

## Load functions

Functions from community selection project

```{python echo = T}
exec(open("script/community_simulator-00A-simulation_algorithm.py").read()) # Single algorithm for simulation `simulate_community()`
exec(open("script/community_simulator-01-regional_pool.py").read())
exec(open("script/community_simulator-02-community_function.py").read())
exec(open("script/community_simulator-02A-community_function_student.py").read()) # Student submitted algorithms
exec(open("script/community_simulator-03-community_selection.py").read())
exec(open("script/community_simulator-03A-community_selection_student.py").read()) # Student submitted algorithms
exec(open("script/community_simulator-04-migration.py").read()) 
exec(open("script/community_simulator-04A-migration_student.py").read()) # Student submitted algorithms
```

Essential functions for community self-assembly

```{r}
# Source python script, like source() in R
reticulate::source_python("script/04A-self_assembly-01-essential_functions.py")
```


# Test simulation 

Use the scripts from community selection project

## Control experiment

Simply passage the wells to the corresponding wells in the next transfer 


Simultion in python code chunk

```{python}
# Setup
## Parameters for different treatments
np.random.seed(0) # Global random seed (i.e all participants)
n = 12  # Number of wells
n_transfer = 10 # Number of transfer
n_propagation = 24 # Length of propagation. How long is one transfer
dilution = 1/1000 # Dilution rate 

## Initial state for the plate based on the parameters
assumptions = a_default.copy() # Start with default parameters
assumptions.update({'n_wells':n, 'c1' :0.01, 'muc':0.1, 'm':0}) # Switch off mortality
init_state = MakeInitialState(assumptions) 
params = MakeParams(assumptions)
species_pool = make_regional_pool(assumptions) # Generate a species pool

# Make plate
np.random.seed(0) # Set seed to get fixed initial plate

## Make plate by default setting. The inital community composition is updated later
ctrl_plate = Community(init_state, dynamics, params, scale = 10**6, parallel = True) 

## Populate the plate by sampling from species pool
ctrl_plate.N = sample_from_pool(ctrl_plate.N, species_pool) 

# Simulation
## Create empty list for recording community/resource composition and community phenotype 
function_simple_df = list()
function_complex_df = list()
plate_N_df = list()
plate_R_df = list()

## Run simulation
for i in range(0, n_transfer):
    # Propagation
    ctrl_plate.Propagate(n_propagation)
    
    # Record community and resource composition
    plate_R_df.append(ctrl_plate.R)
    plate_N_df.append(ctrl_plate.N)
    
    # Measure community phenotype. In this case the phenotype is a simple additive function
    community_function_simple = additive_community_function(ctrl_plate)
    function_simple_df.append(community_function_simple)
    community_function_complex = resource_distance_community_function(ctrl_plate)
    function_complex_df.append(community_function_complex)
    
    # Transfer/passage by usigg transfer matrix. For simple passage, the transfer matrix is an identity matrix
    transfer_matrix = np.eye(n) * dilution
    ctrl_plate.Passage(transfer_matrix)
```


```{r fig.width = 3, fig.height = 2}
# Species
py$plate_N_df %>%
  lapply(function(x) {
    x %>% 
      mutate(Species = factor(1:nrow(.))) %>% 
      pivot_longer(cols = starts_with("W"), names_to = "Community", values_to = "Abundance")
  }) %>% 
  rbindlist(idcol = "Transfer") %>%
  filter(Abundance > 0) %>%
  ggplot(aes(x = Transfer, y = Abundance, color = Species)) +
  geom_point() + geom_line() +
  facet_wrap(Community~.) +
  theme_bw() +
  guides(color = F) +
  ggtitle("Consumer dynamics")
```


```{r fig.width = 3, fig.height = 2}
# Resource
py$plate_R_df %>%
  lapply(function(x) {
    x %>% 
      mutate(Resource = factor(1:nrow(.))) %>% 
      pivot_longer(cols = starts_with("W"), names_to = "Community", values_to = "Abundance")
  }) %>% 
  rbindlist(idcol = "Transfer") %>%
  filter(Abundance > 0) %>%
  ggplot(aes(x = Transfer, y = Abundance, color = Resource)) +
  geom_point() + geom_line() +
  facet_wrap(Community~.) +
  theme_bw() +
  guides(color = F) +
  ggtitle("Resource dynamics")
```

Community phenotype as a function of time. Color denotes communities

```{r fig.width = 3, fig.height = 2}
py$function_simple_df %>%
  lapply(function(x) data.frame(Community = factor(1:length(x)), CommunityPhenotype = x)) %>% 
  rbindlist(idcol = "Transfer") %>%
  ggplot(aes(x = Transfer, y = CommunityPhenotype, color = Community)) +
  geom_point() + geom_line() +
  theme_bw() +
  guides(color = F) +
  ggtitle("Simple trait")

py$function_complex_df %>%
  lapply(function(x) data.frame(Community = factor(1:length(x)), CommunityPhenotype = x)) %>% 
  rbindlist(idcol = "Transfer") %>%
  ggplot(aes(x = Transfer, y = CommunityPhenotype, color = Community)) +
  geom_point() + geom_line() +
  theme_bw() +
  guides(color = F) +
  ggtitle("Complex trait")
```


## Selection experiment 

Selection on the complex trait (distance to ideal resource composition)

```{python eval = F}
# Setup
## Parameters for different treatments
np.random.seed(0) # Global random seed (i.e all participants)
n = 96  # Number of wells
n_transfer = 10 # Number of transfer
n_propagation = 24 # Length of propagation. How long is one transfer
dilution = 1/1000 # Dilution rate 

## Initial state for the plate based on the parameters
assumptions = a_default.copy() # Start with default parameters
assumptions.update({'n_wells':n, 'c1' :0.01, 'muc':0.1, 'm':0}) # Switch off mortality
init_state = MakeInitialState(assumptions) 
params = MakeParams(assumptions)
species_pool = make_regional_pool(assumptions) # Generate a species pool

# Make plate
np.random.seed(0) # Set seed to get fixed initial plate

## Make plate by default setting. The inital community composition is updated later
selection_plate = Community(init_state, dynamics, params, scale = 10**6, parallel = True) 

## Populate the plate by sampling from species pool
selection_plate.N = sample_from_pool(selection_plate.N, species_pool) 

# Simulation
## Create empty list for recording community/resource composition and community phenotype 
function_complex_df = list()
selection_plate_N_df = list()
selection_plate_R_df = list()

## Run simulation
for i in range(0, n_transfer):
    # Propagation
    selection_plate.Propagate(n_propagation)
    
    # Record community and resource composition
    selection_plate_R_df.append(selection_plate.R)
    selection_plate_N_df.append(selection_plate.N)
    
    # Measure community phenotype. In this case the phenotype is a simple additive function
    community_function_complex = resource_distance_community_function(selection_plate)
    function_complex_df.append(community_function_complex)
    
    # Transfer/passage by usigg transfer matrix. For simple passage, the transfer matrix is an identity matrix
    transfer_matrix = pairwise_XZ(community_function_complex) * dilution
    selection_plate.Passage(transfer_matrix)
```


Community phenotype as a function of time. Color denotes communities

```{r fig.width = 3, fig.height = 2}
py$function_complex_df %>%
  lapply(function(x) data.frame(Community = factor(1:length(x)), CommunityPhenotype = x)) %>% 
  rbindlist(idcol = "Transfer") %>%
  ggplot(aes(x = Transfer, y = CommunityPhenotype, color = Community)) +
  geom_point() + geom_line() +
  theme_bw() +
  guides(color = F) +
  ggtitle("Complex trait, selection experiment")
```

