---
title: "Community Simulator student "
author: "Chang-Yu Chang"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: yes
  pdf_document:
    toc: yes
  bookdown::pdf_document2:
    number_sections: no
    toc: no
linkcolor: red
fontsize: 12pt
urlcolor: blue
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  cache = TRUE, 
  echo = TRUE,
	fig.align = "center",
	fig.height = 4,
	fig.width = 6)
  #  engine.path = '~/anaconda3/bin/python3.7m')
library(tidyverse)
library(data.table)
library(reticulate) # Python interface
reticulate::use_python('~/anaconda3/bin/python3.7m')
#library(invnet)
root <- rprojroot::is_r_package
```

# Settings

## Import packages

```{python}
from IPython.display import Image
from community_simulator import *
from community_simulator.usertools import *
from community_simulator.visualization import *
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.backends import backend_pdf as bpdf
colors = sns.color_palette()
#%matplotlib inline
```

## Load the functions

```{python}
exec(open("script/community_simulator-00A-simulation_algorithm.py").read()) # Single algorithm for simulation `simulate_community()`
exec(open("script/community_simulator-01-regional_pool.py").read())
exec(open("script/community_simulator-02-community_function.py").read())
exec(open("script/community_simulator-02A-community_function_student.py").read()) # Student submitted algorithms
exec(open("script/community_simulator-03-community_selection.py").read())
exec(open("script/community_simulator-03A-community_selection_student.py").read()) # Student submitted algorithms
exec(open("script/community_simulator-04-migration.py").read()) 
exec(open("script/community_simulator-04A-migration_student.py").read()) # Student submitted algorithms

```



# Create list of algorithms

Read algorithms and put them into one list

```{r}
# Call function for generation the algorithm list
source("script/community_simulator-00-functions.R")

list_algorithm <- 
  rbind(make_list_of_algorithm(protocol_function = "community_phenotype",  file_name = "script/community_simulator-02A-community_function_student.py"),
        make_list_of_algorithm(protocol_function = "selection_function", file_name = "script/community_simulator-03A-community_selection_student.py"), 
        make_list_of_algorithm(protocol_function = "migration_function", file_name = "script/community_simulator-04A-migration_student.py"))

# Remove Julie's selection function
list_algorithm <- list_algorithm %>%
  filter(!(Author == "Julie" & Algorithm == "selection_function"))

fwrite(list_algorithm, file = "script/data/list_algorithm.csv", sep = ",")
```

```{r}
list_algorithm <- fread("script/data/list_algorithm.csv")
list_algorithm
```

List of algorithms that we have 

```{r}
list_algorithm %>%
  group_by(Algorithm) %>%
  summarize(CountAlgorithm = n())
```


Read the list of algorithms in python

```{python}
list_algorithm = pd.read_csv("script/data/list_algorithm.csv")
community_phenotype_list = list_algorithm.loc[list_algorithm.Algorithm.isin(['community_phenotype'])]
selection_function_list = list_algorithm.loc[list_algorithm.Algorithm.isin(['selection_function'])]
migration_function_list = list_algorithm.loc[list_algorithm.Algorithm.isin(['migration_function'])]
```


# Test algorithms 

## Community phenotype

```{python eval = FALSE}
#exec(open("script/community_simulator-03A-community_selection_student.py").read())
exec(open("script/community_simulator-03B-test_community_selection.py").read())
```

```{python}
pd.read_csv('script/data/test_selection_function_report.csv', sep = ',')
````


## Selection functions

```{python eval = FALSE}
#exec(open("script/community_simulator-03A-community_selection_student.py").read())
exec(open("script/community_simulator-03B-test_community_selection.py").read())
```

```{python}
pd.read_csv('script/data/test_selection_function_report.csv', sep = ',')
````

## Test migration functions

```{python eval = FALSE}
exec(open("script/community_simulator-04B-test_community_selection.py").read())
```

```{python}
pd.read_csv('script/data/test_migration_function_report.csv', sep = ',')
````


# Simulate community

Community simulation in a python script

```{python eval = F}
exec(open("script/community_simulator-00-simulation.py").read())
```


# Simulated result


## Read community function csv 

Read file name. (deprecated because the variable name is already in the csv)

```{r include = F}
result_list <- list.files("script/data/", "resource_distance_community_function")
result_df <- result_list %>%
  gsub("\\.csv", "", .) %>%
  strsplit("-") %>% unlist %>%
  matrix(ncol = 7, byrow = T) %>%
  as.data.frame() %>%
  setNames(c("CommunityPhenotypeID", "CommunityPhenotype", 
             "SelectionFunctionID", "SelectionFunction", "MigrationFuntionID", "MigrationFunction", "Replicate"))
table(result_df$SelectionFunction)
```

Read and bind the csv files and output the rbinded function.

```{r}
# Read and rbind the simulated result csv files ----
source("script/community_simulator-00-functions.R")
read_bind_csv("additive_community_function")
read_bind_csv("resource_distance_community_function")
```


## Plot the result


### Additive community function 

```{r}
result <- fread("script/data/binded-additive_community_function.csv")
dim(result)
str(result)
```



```{r}
p1 <- result %>%
  group_by(SelectionFunction, Time) %>%
  summarise(MeanPhenotypeValue = mean(PhenotypeValue)) %>%
  ggplot(aes(x = Time, y = MeanPhenotypeValue, color = SelectionFunction)) +
  geom_line() + 
  theme_bw()

p2 <- result %>%
  group_by(SelectionFunction, Time) %>%
  summarise(MaxPhenotypeValue = max(PhenotypeValue)) %>%
  ggplot(aes(x = Time, y = MaxPhenotypeValue, color = SelectionFunction)) +
  geom_line() + 
  theme_bw()


p3 <- result %>%
  filter(SelectionFunction %in% c("pairwise_XZ", "select_best_n")) %>%
  ggplot(aes(x = Time, y = PhenotypeValue, color = SelectionFunction)) +
  geom_jitter(size=0.01) + 
  scale_shape(solid = FALSE) +
  theme_bw()

# Boxplot
p_boxplot1 <- result %>%
  filter(SelectionFunction %in% c("pairwise_XZ", "select_best_n", "exponealing", "exponealing2"), Time == 19) %>%
  ggplot(aes(x = SelectionFunction, y = PhenotypeValue, color = SelectionFunction)) +
  geom_boxplot() +
  theme_bw()

pdf("figure/00-function-phenotype_value.pdf", width = 10, height = 8); p1; p2 ; p3; p_boxplot1; dev.off()
```


### resource_distance_community_function

```{r}
result <- fread("script/data/binded-resource_distance_community_function.csv")
dim(result)
str(result)
```

Best experimetnal protocol
```{r}
result %>%
  filter(Time == 19) %>%
  group_by(CommunityPhenotype, SelectionFunction, MigrationFunction) %>%
  summarize(MaxPhenotypeValue = max(PhenotypeValue), 
            MeanPhenotypeValue = mean(PhenotypeValue)) %>%
  arrange(desc(MeanPhenotypeValue))

```



Heatmap of the functions

```{r}
p_tile <- result %>%
  group_by(CommunityPhenotype, SelectionFunction, MigrationFuntion, Time) %>%
  summarise(MeanPhenotypeValue = mean(PhenotypeValue),
            SdPhenotypeValue = sd(MeanPhenotypeValue)) %>%
  filter(Time == 19) %>%
  ggplot() +
  geom_tile(aes(x = MigrationFuntion, y = SelectionFunction, fill = MeanPhenotypeValue)) +
  scale_fill_gradient(low = "white", high = "tomato") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Migration algorithms")

p_dot <- result %>%
  group_by(CommunityPhenotype, SelectionFunction, MigrationFuntion, Time) %>%
  summarise(MeanPhenotypeValue = mean(PhenotypeValue),
            SdPhenotypeValue = sd(MeanPhenotypeValue)) %>%
  filter(Time == 19) %>%
  ggplot(aes(x = MigrationFuntion, y = MeanPhenotypeValue, color = SelectionFunction)) +
  geom_point() +
  facet_wrap(SelectionFunction~.) + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Migration algorithms")

pdf("figure/01-function-tile.pdf", width = 10, height = 8); p_tile; p_dot; dev.off()
```


```{r}
p1 <- result %>%
#  select(-CommunityPhenotypeID, -SelectionFunctionID, -MigrationFuntionID) %>%
  group_by(CommunityPhenotype, SelectionFunction, MigrationFuntion, Time) %>%
  summarise(MeanPhenotypeValue = mean(PhenotypeValue)) %>%
  ggplot(aes(x = Time, y = MeanPhenotypeValue, color = MigrationFuntion)) +
  geom_line() +
  facet_wrap(SelectionFunction~.) +
  theme_bw()


p2 <- result %>%
#  select(-CommunityPhenotypeID, -SelectionFunctionID, -MigrationFuntionID) %>%
  group_by(CommunityPhenotype, SelectionFunction, MigrationFuntion, Time) %>%
  summarise(MaxPhenotypeValue = max(PhenotypeValue)) %>%
  ggplot(aes(x = Time, y = MaxPhenotypeValue, color = MigrationFuntion)) +
  geom_line() +
  facet_wrap(SelectionFunction~.) +
  theme_bw()

p3 <- result %>%
  filter(SelectionFunction %in% c("select_above_avg_save_losers", "pairwise_XZ", "select_best_n")) %>%
  ggplot(aes(x = Time, y = PhenotypeValue, color = MigrationFuntion)) +
  geom_jitter(size=0.01) + 
  scale_shape(solid = FALSE) +
  facet_grid(SelectionFunction~.) +
  theme_bw()

pdf("figure/01-function-phenotype_value.pdf", width = 13, height = 10); p1; p2; p3; dev.off()
```



## Read commnunity compostion by transfer

```{r}
source("script/community_simulator-00-functions.R")
suppressWarnings(read_bind_transfer_csv(community_phenotype = "resource_distance_community_function"))
```

### Read bindned community 

```{r}
result <- fread("script/data/binded-passage-resource_distance_community_function.csv")
dim(result)
```


Write community composition at laste transfer

```{r}
result %>%
  filter(Passage == "T19", Type == "N") %>%
  fwrite(file = "script/data/passage-resource_distance_community_function-T19.csv")
```


Species richness

```{r}
result_richness <- result %>%
#  filter(SelectionFunction %in% c("pairwise_XZ", "select_above_avg_save_losers")) %>%
  filter(Type == "N", Abundance != 0) %>%
  group_by(SelectionFunction, MigrationFunction, Passage, Well) %>%
  summarize(Richness = n())

p1 <- result_richness %>%
  ggplot(aes(x = Passage, y = Richness, color = SelectionFunction)) +
  geom_jitter(size = 0.01) +
  facet_wrap(MigrationFunction~.) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        legend.position = "top") +
  NULL

pdf("figure/01-function-richness.pdf", width = 10, height = 10); p1; dev.off()
```

```{r}
p_stack_N <- result %>%
  filter(Type == "N", Abundance != 0) %>% 
  mutate(Species = as.character(TypeID)) %>%
#  filter(Well == "W0")  %>%
  filter(Passage == "T19") %>%
  ggplot(aes(x = Well, y = Abundance, fill = Species)) +
  geom_bar(stat = "identity") +
  facet_grid(MigrationFunction~SelectionFunction) +
  theme_minimal() +
  guides(fill = FALSE) +
  theme(axis.text.x = element_blank())


# Resource composition
p_stack_R <- result %>%
  filter(Type == "R", Abundance != 0) %>% 
  mutate(Resource = as.character(TypeID)) %>%
#  filter(Well == "W0")  %>%
  filter(Passage == "T19") %>%
  ggplot(aes(x = Well, y = Abundance, fill = Resource)) +
  geom_bar(stat = "identity") +
  facet_grid(MigrationFunction~SelectionFunction) +
  theme_minimal() +
  guides(fill = FALSE) +
  theme(axis.text.x = element_blank())

## 
p_stack_R2 <- result %>%
  filter(Type == "R", Abundance != 0) %>% 
  mutate(Resource = as.character(TypeID)) %>%
  filter(SelectionFunction == "select_above_avg_save_losers") %>%
#  filter(Well == "W0")  %>%
  filter(Passage == "T00") %>%
  ggplot(aes(x = Well, y = Abundance, fill = Resource)) +
  geom_bar(stat = "identity") +
  facet_grid(MigrationFunction~SelectionFunction) +
  theme_minimal() +
  guides(fill = FALSE) +
  theme(axis.text.x = element_blank())



pdf("figure/01-function-stack.pdf", width = 10, height = 10); p_stack_N; p_stack_R; p_stack_R2; dev.off()
```




# Test simulation

```{python eval = F}
phenotype_algorithm = "resource_distance_community_function"
selection_algorithm = "pairwise_XZ"
migration_algorithm = "no_migration"
n = 96
n_propagation = 2
dilution=1/1000
replicate_index = 1
write_composition=False

plate2, function_df = test_simulate_community(assumptions, phenotype_algorithm, selection_algorithm, migration_algorithm, n = 96, n_propagation = 2, dilution=1/1000, replicate_index = 1, write_composition=False)
```


```{python}
#
phenotype_algorithm = "resource_distance_community_function"
selection_algorithm = "pairwise_XZ"
migration_algorithm = "no_migration"
n = 96
n_propagation = 2
dilution=1/1000
replicate_index = 1
write_composition=False

#
np.random.seed(0) #you are all going to get the same species pool
assumptions=a_default.copy() #Start with default parameters
assumptions.update({'n_wells':n, 'c1' :.01, 'muc':0.1, 'm':0})  # default setting
init_state = MakeInitialState(assumptions)
params = MakeParams(assumptions)
species_pool = RegionalSpeciesPool(assumptions) # Generate a species pool

# Make plate
np.random.seed(replicate_index) # Change to a unique number so that you each start the experiment with a slightly different species pool
plate1 = Community(init_state,dynamics,params,scale = 10**6,parallel=True) # Reset the community
plate1.N = SampleFromPool(plate1.N,species_pool) # Populate the well by sampling from the species pool

# Propagate communities
function_df = list()
plate_N_df = list()

for k in range(n_propagation):
    # Propagation
    plate1.Propagate(24)
    
#    if write_composition == True:
#            plate_N_df = list()
#        plate1.N.to_csv("data/passages/" + "{:02d}".format(phenotype_algorithmID) + "-" + phenotype_algorithm + "-" +"{:02d}".format(selection_algorithmID) + "-" + selection_algorithm + "-" +"{:02d}".format(migration_algorithmID) + "-" + migration_algorithm + "-" + "{:02d}".format(rr) + "-T" + "{:02d}".format(k) + ".csv", index=False)

    # Community phenotype
    community_function = globals()[phenotype_algorithm](plate1)
    function_df.append(community_function)
    
    # Passage and tranfer matrix
    if selection_algorithm in ["exponealing", "exponealing2"]: # Propagation time dependent function
        t = globals()[selection_algorithm](community_function, k)
    else:
        t = globals()[selection_algorithm](community_function)
    
    plate1.Passage(t*dilution)
    
    # Migration
    m = globals()[migration_algorithm](community_function) 
    plate1.N = migrate_from_pool(plate1, species_pool, m)
    
    # Print the propagation progress
    print("propagation: " + str(k)) 
```

Plot species composition and functions

```{python}
StackPlot(plate1.N)
resource_distance_community_function(plate1)
```




# Resource composition

```{python}
def resource_distance_community_function(plate,low=0,high=0.1,sigma = 0.01): #Sigma is the measurement error
   R_tot = plate.R.shape[0]
   well_tot = plate.R.shape[1]
   # Assign additive traits to each species
   if not hasattr(resource_distance_community_function, 'R_target'):
       np.random.seed(0)
       R_target = np.concatenate([np.zeros(1),np.random.uniform(low, high, size=R_tot-1)])
   R_dist = np.sqrt(np.sum((np.tile(R_target,(well_tot,1)) - plate.R.T)**2,axis=1))
   return np.array(R_dist.T)* -1 #(so we select for positive community function)



def ideal_resource(R_tot=90, well_tot = 96,low=0,high=0.1,sigma = 0.01): #Sigma is the measurement error
   # Assign additive traits to each species
   if not hasattr(resource_distance_community_function, 'R_target'):
       np.random.seed(0)
       R_target = np.concatenate([np.zeros(1),np.random.uniform(low, high, size=R_tot-1)]) 
   #R_dist = np.sqrt(np.sum((np.tile(R_target,(well_tot,1)) - plate.R.T)**2,axis=1)) # Transpose the plate
   #return np.array(R_dist.T)* -1 #(so we select for positive community function)
   return R_target #(so we select for positive community function)
```


```{python}
idea_resource_composition = ideal_resource()
np.sum(idea_resource_composition)
```

```{r}
py$idea_resource_composition
```








