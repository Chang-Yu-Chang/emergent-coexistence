#' This script generates an output csv with T0 vs.T8 frequencies for each competing pairs
#' 1. correct T0 OD frequency to CFU frequency
#' 2. clean up T8 column names
#' 3. compare T0 CFU frequencies to T8 bootstrap

library(tidyverse)
library(cowplot)

folder_script <- "~/Desktop/Lab/emergent-coexistence/output/check/"
folder_main <- "~/Dropbox/lab/emergent-coexistence/data/raw/plate_scan/emergent_coexistence_plate_scan_check/"
boots <- read_csv(paste0(folder_main, "meta/bootstraps.csv"), show_col_types = F) # Bootstrapped results using the object probability
pairs_freq <- read_csv("~/Dropbox/lab/emergent-coexistence/data/raw/pairwise_competition/result_pairwise_competition_arranged.csv", show_col_types = F) # human-eye results

# 0. Pairs ID ----
pairs_ID <- pairs_freq %>%
    mutate(Batch = str_replace(Experiment, "Transitivity_", "")) %>%
    select(Batch, Community, Isolate1, Isolate2, Isolate1InitialODFreq = Isolate1Freq, Isolate2InitialODFreq = Isolate2Freq)

# 1. Correct T0 OD to CFU frequencies ----
# Read isolates epsilon uncertainty. isolates_epsilon_uncertainty.csv is generated by `script/02B-pairs_OD_CFU-01-epsilon_uncertainty.R`
isolates_epsilon_uncertainty <- read_csv("~/Dropbox/lab/emergent-coexistence/data/temp/isolates_epsilon_uncertainty.csv", show_col_types = F) %>%
    select(Community, Isolate, Epsilon, ErrorEpsilon)

pairs_epsilon <- pairs_ID %>%
    left_join(rename(isolates_epsilon_uncertainty, Isolate1 = Isolate, Epsilon1 = Epsilon, ErrorEpsilon1 = ErrorEpsilon), by = c("Community", "Isolate1")) %>%
    left_join(rename(isolates_epsilon_uncertainty, Isolate2 = Isolate, Epsilon2 = Epsilon, ErrorEpsilon2 = ErrorEpsilon), by = c("Community", "Isolate2"))

# Uncertainty in T0 OD-converted CFU frequencies
pairs_T0 <- pairs_epsilon %>%
    # Initial OD frequencies
    mutate(
        Isolate1ODFreq = Isolate1InitialODFreq / 100,
        Isolate2ODFreq = Isolate2InitialODFreq / 100,
    ) %>%
    # Partial derivatives
    mutate(
        PartialEpsilon1 =  Isolate1ODFreq * Isolate2ODFreq * Epsilon2 / (Isolate1ODFreq * Epsilon1 + Isolate2ODFreq * Epsilon2)^2,
        PartialEpsilon2 = -Isolate1ODFreq * Isolate2ODFreq * Epsilon1 / (Isolate1ODFreq * Epsilon1 + Isolate2ODFreq * Epsilon2)^2
    ) %>%
    mutate(
        Isolate1CFUFreq = Isolate1ODFreq * Epsilon1 / (Isolate1ODFreq * Epsilon1 + Isolate2ODFreq * Epsilon2),
        ErrorIsolate1CFUFreq = sqrt((PartialEpsilon1 * ErrorEpsilon1)^2 + (PartialEpsilon2 * ErrorEpsilon2)^2)
    ) %>%
    mutate(Time = "T0") %>%
    select(Community, Isolate1, Isolate2, Isolate1InitialODFreq, Isolate2InitialODFreq, Isolate1CFUFreq, ErrorIsolate1CFUFreq) %>%
    # Add one variable `RawDataType`. This variable specifies where the freq data is collected
    mutate(RawDataType = case_when(
        !is.na(Isolate1CFUFreq) ~ "ODtoCFU", # T0 OD converted to CFU using epsilon
        is.na(Isolate1CFUFreq) ~ "OD" # T0 OD
    )) %>%
    # If one isolate in the pair does not have epsilon value, then use OD frequency at T0
    mutate(Isolate1CFUFreq = case_when(
        is.na(Isolate1CFUFreq) ~ Isolate1InitialODFreq / 100,
        !is.na(Isolate1CFUFreq) ~ Isolate1CFUFreq,
    ))

## 39 pair-frequency -> 13 unique species pairs does not have T0 CFU
pairs_T0 %>%
    distinct(Community, Isolate1, Isolate2, .keep_all = T) %>%
    filter(is.na(ErrorIsolate1CFUFreq))


## Generate T0 bootstraps
n_bootstraps = 1000
pairs_T0_boots <- rep(list(NA), nrow(pairs_ID))
i=1
set.seed(1)
for (i in 1:nrow(pairs_T0)) {
    if (!is.na(pairs_T0$ErrorIsolate1CFUFreq[i])) error_isolate1_cfu_freq <- pairs_T0$ErrorIsolate1CFUFreq[i]
    if (is.na(pairs_T0$ErrorIsolate1CFUFreq[i])) {
        error_isolate1_cfu_freq <- 0
        cat("\n", pairs_T0$Community[i], pairs_T0$Isolate1[i], pairs_T0$Isolate2[i], "uses the T0 OD frequency")
    }

    pairs_T0_boots[[i]] <- tibble(
        Community = pairs_T0$Community[i],
        Isolate1 = pairs_T0$Isolate1[i],
        Isolate2 = pairs_T0$Isolate2[i],
        Isolate1InitialODFreq = pairs_T0$Isolate1InitialODFreq[i],
        Isolate2InitialODFreq = pairs_T0$Isolate2InitialODFreq[i],
        Time = "T0",
        RawDataType = pairs_T0$RawDataType[i],
        BootstrapID = 1:n_bootstraps,
        Isolate1CFUFreq = rnorm(n_bootstraps,
                                mean = pairs_T0$Isolate1CFUFreq[i],
                                sd = error_isolate1_cfu_freq)
    )
}

pairs_T0_boots <- bind_rows(pairs_T0_boots)




# 2. Clean up the T8 names ----
pairs_image_ID <- boots %>%
    distinct(image_name_pair, .keep_all = T) %>%
    separate(image_name_pair, into = c("Batch", "Time", "Community", "Isolate2Freq", "Isolate1Freq", "Isolate1", "Isolate2"), convert = T, remove = F) %>%
    select(image_name_pair, Batch, Community, Isolate1, Isolate2,
           Isolate1InitialODFreq = Isolate1Freq, Isolate2InitialODFreq = Isolate2Freq, Time) %>%
    mutate(RawDataType = "CFU-random_forest") %>%
    #filter(Isolate1InitialODFreq == 5) %>% head() %>%
    # Correct the isolate order
    rowwise() %>%
    mutate(Isolate1InitialODFreq = ifelse(Isolate1 > Isolate2, 5, Isolate1InitialODFreq),
           Isolate2InitialODFreq = ifelse(Isolate1 > Isolate2, 95, Isolate2InitialODFreq),
           FlipOrder = ifelse(Isolate1 > Isolate2, T, F)
    ) %>%
    mutate(temp = min(Isolate1,Isolate2), Isolate2 = max(Isolate1, Isolate2), Isolate1 = temp) %>%
    select(-temp) %>%
    mutate(Community = factor(Community, paste0("C", rep(1:12, each = 8), "R", rep(1:8, 12)))) %>%
    arrange(Community, Isolate1, Isolate2, Isolate1InitialODFreq) %>%
    # Remove C11R2 isolate 13, which is a Staph. It's also not included in isolates_ID_match
    filter(!((Community == "C11R2" & Isolate1 == 13) | ((Community == "C11R2" & Isolate2 == 13)))) %>%
    # Remove batch B2 C11R1 pairs that contains isolate 1
    filter(!(Batch == "B2" & Community == "C11R1" & (Isolate1 == 1 | Isolate2 == 1))) %>%
    # Keep batch C C11R1 pairs that contains isolate 1
    filter(!(Batch == "C" & Community == "C11R1" & (Isolate1 != 1 & Isolate2 != 1)))

pairs_T8_boots <- pairs_image_ID %>%
    left_join(boots, by = "image_name_pair") %>%
    # The order of isolates is flipped for these pairs
    mutate(Isolate1Count= ifelse(FlipOrder, TotalCount - Isolate1Count, Isolate1Count)) %>%
    mutate(Isolate1CFUFreq = Isolate1Count / TotalCount) %>%
    #select(all_of(colnames(pairs_T0_boots))) %>%
    ungroup()


# 3. Append T0 bootstraps to T8 bootstraps ----
pairs_fitness_ID <- pairs_ID %>% select(-Batch)
temp <- rep(list(NA), nrow(pairs_fitness_ID))

i = which(pairs_fitness_ID$Community == "C2R8" & pairs_fitness_ID$Isolate1 == 3 & pairs_fitness_ID$Isolate2 == 4 &
          pairs_fitness_ID$Isolate1InitialODFreq == 50)

for (i in 1:nrow(pairs_fitness_ID)) {
    community <- pairs_fitness_ID$Community[i]
    isolate1 <- pairs_fitness_ID$Isolate1[i]
    isolate2 <- pairs_fitness_ID$Isolate2[i]
    isolate1_freq <- pairs_fitness_ID$Isolate1InitialODFreq[i]
    isolate2_freq <- pairs_fitness_ID$Isolate2InitialODFreq[i]

    pairs_T0_boot <- pairs_T0_boots %>%
        filter(Community == community, Isolate1 == isolate1, Isolate2 == isolate2,
               Isolate1InitialODFreq == isolate1_freq, Isolate2InitialODFreq == isolate2_freq)

    pairs_T8_boot <- pairs_T8_boots %>%
        filter(Community == community, Isolate1 == isolate1, Isolate2 == isolate2,
               Isolate1InitialODFreq == isolate1_freq, Isolate2InitialODFreq == isolate2_freq)

    if (nrow(pairs_T8_boot) == 0) {
        cat("\nNo colony on T8 for", paste(community, isolate1, isolate2, isolate1_freq, isolate2_freq, sep = " "))
        next
    }

    temp[[i]] <- bind_rows(pairs_T0_boot, pairs_T8_boot) %>%
        select(Community, Isolate1, Isolate2, Isolate1InitialODFreq, Time, BootstrapID, Isolate1CFUFreq) %>%
        pivot_wider(names_from = Time, values_from = Isolate1CFUFreq) %>%
        mutate(FreqChange = T8-T0) %>%
        mutate(FreqChangeSign = case_when(
            FreqChange > 0 ~ "increase",
            FreqChange == 0 ~ "same",
            FreqChange < 0 ~ "decrease",
        ))
    cat(" ", i)
}

pairs_fitness <- bind_rows(temp[which(!is.na(temp))])


# 4. Plot the frequency change for each bootstrap for each coculture----
# pairs_T0_boots
# pairs_T8_boots

bind_rows(
    filter(pairs_T0_boots, Community == "C1R2", Isolate1 == 2, Isolate2 == 3),
    filter(pairs_T8_boots, Community == "C1R2", Isolate1 == 2, Isolate2 == 3),
) %>%
    select(Community, Isolate1, Isolate2, Isolate1InitialODFreq, Time, BootstrapID, Isolate1CFUFreq) %>%
    ggplot() +
    geom_point(aes(x = Time, y = Isolate1CFUFreq), shape = 21) +
    ## Add color on increase or decrease
    geom_line(aes(x = Time, y = Isolate1CFUFreq, group = BootstrapID), size = .1) +
    facet_grid(.~Isolate1InitialODFreq) +
    theme_bw() +
    theme(panel.border = element_rect(color = 1, fill = NA)) +
    ggtitle("")

#     ggplot() +
#     geom_histogram(aes(x = Isolate1CFUFreq, fill = Time), color = 1) +
#     facet_grid(Isolate1InitialODFreq ~ Time, scales = "free_y") +
#     coord_flip() +
#     theme_bw() +
#     theme(panel.border = element_rect(color = 1, fill = NA))

pairs_T0_boots %>%
    filter(Community == "C1R2", Isolate1 == 2, Isolate2 == 3) %>%
    #group_by(Isolate1InitialODFreq) %>%
    ggplot() +
    geom_histogram(aes(x = Isolate1CFUFreq)) +
    facet_grid(Isolate1InitialODFreq ~ .) +
    theme_classic



"
check the below T8
C11R1 1 2 50-50
C11R1 1 3 50-50
No colony on T8 for C11R1 2 8 5 95
No colony on T8 for C11R1 2 8 50 50
No colony on T8 for C11R1 2 8 95 5
No colony on T8 for C11R1 2 9 50 50
No colony on T8 for C11R1 2 9 95 5
No colony on T8 for C11R1 8 9 5 95
No colony on T8 for C11R2 2 10 50 50
that should have colonies
"

# 5. Calculate significance of frequency change ----
make_interaction_type <- function () {

    interaction_type_three <- tibble(
        FromRare = rep(c(1, -1, 0), each = 9),
        FromMedium = rep(rep(c(1, -1, 0), each = 3), 3),
        FromAbundant = rep(c(1, -1, 0), 9),
        InteractionType = NA,
        InteractionTypeFiner = NA
    )
    interaction_type_two <- tibble(
        FromRare = rep(c(1, -1, 0), each = 3),
        FromMedium = rep(NA, 9),
        FromAbundant = rep(c(1, -1, 0), 3),
        InteractionType = NA,
        InteractionTypeFiner = NA
    )

    interaction_type <- bind_rows(interaction_type_three, interaction_type_two)

    ## Assign interaction types to combinations of frequency changes signs
    interaction_type$InteractionType[c(1, 14, 28, 32, 10, 13, 31)] <- "exclusion"
    interaction_type$InteractionType[c(2, 3, 5, 8, 9, 23, 26, 29, 30, 33, 4, 11, 12, 15, 17, 20, 34, 35)] <- "coexistence"
    interaction_type$InteractionType[c(27, 36)] <- "neutrality"

    ## Assign finer interaction types to combinations of frequency changes signs
    interaction_type$InteractionTypeFiner[c(1, 14, 28, 32)] <- "competitive exclusion"
    interaction_type$InteractionTypeFiner[c(10, 13, 31)] <- "mutual exclusion"
    interaction_type$InteractionTypeFiner[c(2, 3, 5, 8, 9, 23, 26, 29, 30, 33)] <- "stable coexistence"
    interaction_type$InteractionTypeFiner[c(4, 11, 12, 15, 17, 20, 34, 35)] <- "frequency-dependent coexistence"
    interaction_type$InteractionTypeFiner[c(27,36)] <- "neutrality"
    interaction_type <- interaction_type %>%  mutate(FitnessFunction = paste(FromRare, FromMedium, FromAbundant, sep = "_"))
}
interaction_type <- make_interaction_type()

pairs_outcome <- pairs_fitness %>%
    mutate(FreqChangeSign = factor(FreqChangeSign, c("increase", "decrease", "same"))) %>%
    group_by(Community, Isolate1, Isolate2, Isolate1InitialODFreq, FreqChangeSign, .drop = F) %>%
    count(name = "Count") %>%
    mutate(Community = factor(Community, paste0("C", rep(1:12, each = 8), "R", rep(1:8, 12)))) %>%
    arrange(Community, Isolate1, Isolate2, Isolate1InitialODFreq) %>%
    group_by(Community, Isolate1, Isolate2, Isolate1InitialODFreq, .drop = F) %>%
    mutate(Fraction = Count / sum(Count)) %>%
    pivot_wider(id_cols = c(Community, Isolate1, Isolate2, Isolate1InitialODFreq), names_from = FreqChangeSign, values_from = Fraction) %>%
    #select(Community, Isolate1, Isolate2, Isolate1InitialODFreq, )
    #filter(increase > 0.95 | increase < 0.05) %>%
    mutate(FitnessChange = case_when(
        increase > 0.95 ~ 1,
        decrease > 0.95 ~ -1,
        increase < 0.95 & decrease < 0.95 ~ 0
    )) %>%
    pivot_wider(id_cols = c(Community, Isolate1, Isolate2), names_from = Isolate1InitialODFreq, values_from = FitnessChange) %>%
    rename(FromRare = `5`, FromMedium = `50`, FromAbundant = `95`) %>%
    left_join(interaction_type)

pairs_outcome %>% view()



pairs_outcome %>%
    unite(col = "FitnessFunction", FromRare, FromMedium, FromAbundant, sep = "_") %>%
    group_by(FitnessFunction) %>%
    count(name = "Count")


















