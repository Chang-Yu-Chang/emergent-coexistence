---
title: "R Notebook"
output: html_notebook
---

```{r setup, include=FALSE}
#knitr::opts_chunk()
library(tidyverse)
library(EBImage)
library(reticulate)
folder_main <- "/Users/chang-yu/Dropbox/lab/emergent-coexistence/data/raw/plate_scan/emergent_coexistence_plate_scan_check/"
```


Example pair 

D_T8_C1R2_1
D_T8_C1R2_2 
D_T8_C1R2_5-95_1_2


```{r}
# list_images <- tibble(
#     image_name = c("D_T8_C1R2_1", "D_T8_C1R2_2", "D_T8_C1R2_5-95_1_2"),
#     folder_original = rep(paste0(folder_main, "check/D-00-original/"), 3),
#     folder_green = rep(paste0(folder_main, "example/"), 3),
#     folder_green_rolled = rep(paste0(folder_main, "example/"), 3),
#     folder_green_watershed = rep(paste0(folder_main, "example/"), 3),
#     folder_green_feature = rep(paste0(folder_main, "example/"), 3),
#     folder_green_cluster = rep(paste0(folder_main, "example/"), 3)
# )

list_images <- read_csv("~/Desktop/Lab/emergent-coexistence/output/check/00-list_images-D.csv")

i = which(list_images$image_name == "D_T8_C1R2_1")
image_name <- list_images$image_name[i]

```

# 0. original image

```{r}
image_original <- readImage(paste0(list_images$folder_original[i], image_name, ".tiff"))
writeImage(image_original, paste0(folder_main, "example/", image_name, "-00-original.tiff"))
display(image_original, method = "raster")
```

# 1. Green channel

```{r}
temp <- image_original
colorMode(temp) = Grayscale
image_green <- temp[,,2]
writeImage(image_green, paste0(folder_main, "example/", image_name, "-01-green.tiff"))
display(image_green, method = "raster")
```



# 2. Rolling ball

Python code from `rolling_ball.py`

```{r}
py$file_green <- paste0(list_images$folder_green[i], image_name, ".tiff")
py$file_green_rolled <- paste0(list_images$folder_green_rolled[i], image_name, "-02-rolled.tiff")
```

The R variables should be passed to python but somehow failed. Not sure where the problem is from, probably reticualte. 20220902 use the externally generated rolled images.

```{python eval = F}
import imageio
import os
import sys
import skimage
from skimage import data, restoration, util, io, color

def rolling_ball_light(image):
    # 2. invert the image
    image_inverted = util.invert(image)
    
    # 3. rolling ball
    background_inverted = restoration.rolling_ball(image_inverted, radius = 80, num_threads = 10)
    
    # 4. invert the result
    image_rolled_inverted = image_inverted - background_inverted
    image_rolled = util.invert(image_rolled_inverted)
    return image_rolled
    
image = io.imread(file_green)
image_rolled = rolling_ball_light(image)
io.imsave(file_green_rolled, image_rolled)
```

Display the rolled result

```{r}
image_rolled <- readImage(paste0(list_images$folder_green_rolled[i], image_name, ".tiff"))
writeImage(image_rolled, paste0(folder_main, "example/", image_name, "-02-green_rolled.tiff"))
display(image_rolled, method = "raster")
```



# 3. Thresholding

Here because the images have undergone gray scale and background subtraction so I apply a global threshold to the image

```{r}
threshold <- otsu(image_rolled)
image_thresholded <- image_rolled < threshold
writeImage(image_thresholded, paste0(folder_main, "example/", image_name, "-03-threshold.tiff"))
display(image_thresholded, method = "raster")
```

# 4. Detect round shaped object and remove super small size

To select potential colonies: area, perimeter, and circularity.

This step is implemented here to prevent over segmentation and reduce segmentation load

As you can see here, attached objects are not divided yet

```{r}
detect_nonround_object <- function (image_object, watershed = F) {
    # Reomve too large or too small objects before watershed to reduce computational load
    if (!watershed) {
        object_shape <- computeFeatures.shape(image_object) %>% as_tibble(rownames = "ObjectID")
        object_shape_round <- object_shape %>%
            # Area
            filter(s.area > 300 & s.area < 20000)
    }

    # Filter for circularity only after watershed segmentation
    if (watershed) {
        object_shape <- computeFeatures.shape(image_object) %>% as_tibble(rownames = "ObjectID")
        object_moment <- computeFeatures.moment(image_object) %>% as_tibble(rownames = "ObjectID")

        object_shape_round <- object_shape %>%
            left_join(object_moment, by = "ObjectID") %>%
            # Circularity = 1 means a perfect circle and goes down to 0 for non-circular shapes
            mutate(Circularity = 4 * pi * s.area / s.perimeter^2) %>%
            filter(Circularity > 0.3) %>%
            # Remove tape and label that has really large variation in radius
            filter(s.radius.sd/s.radius.mean < 1/2) %>%
            filter(m.eccentricity < 0.8) # Circle eccentricity=0, straight line eccentricity=1
    }

    # Arrange by area size
    object_shape_round <- object_shape_round %>% arrange(desc(s.area))
    object_ID_nonround <- object_shape$ObjectID[!(object_shape$ObjectID %in% object_shape_round$ObjectID)]
    return(object_ID_nonround)
}
```


Filter objects by size

```{r}
image_object <- bwlabel(image_thresholded)
object_ID_nonround <- detect_nonround_object(image_object, watershed = F)
image_round <- rmObjects(image_object, object_ID_nonround, reenumerate = T)
writeImage(image_round, paste0(folder_main, "example/", image_name, "-04-size_objects.tiff"))
display(image_round, method = "raster")
```


# 5. Distance map

The distance map contains for each pixel the distance to the nearest background pixe


```{r}
image_distancemap <- distmap(image_round)
writeImage(normalize(image_distancemap), paste0(folder_main, "example/", image_name, "-05-distancemap.tiff"))
display(normalize(image_distancemap), method = "raster")
```


# 6. Watershed

This is the actual segmentation step. Here the adjacent objects are better distinguished

```{r}
image_watershed <- watershed(image_distancemap, tolerance = 1)
# A second filter by density and eccentricity
object_ID_nonround2 <- detect_nonround_object(image_watershed, watershed = T)
image_watershed2 <- rmObjects(image_watershed, object_ID_nonround2, reenumerate = T)
writeImage(colorLabels(image_watershed2), paste0(folder_main, "example/", image_name, "-06-watershed.tiff"))
display(colorLabels(image_watershed2), method = "raster")
```
# 7. Features

```{r}
image_watershed <- watershed(image_distancemap, tolerance = 1)
display(colorLabels(image_watershed), method = "raster")
```


##

```{r}
# 7. Calculate the features
library(EBImageExtra)
library(purrr)
extract_transection <- function (watershed, ref) {
    #' This function searches for all objects on an image and return the pixel intensity along the transection of each object
    #' Arguments:
    #'  watershed is the watershed image with object labels
    #'  ref is the original image with intensity data. This has to be single-channel
    oc <- ocontour(watershed) # all contour points
    transection <- NULL
    #max_radius <- NULL # A test for object ID -> good. As long I use the oc output, they should be good
    for (j in 1:length(oc)) {
        z <- oc[[j]] # coordinate of contour pixels
        cz <- apply(z, 2, mean) # object center
        radius <- sqrt(rowSums((z - rep(cz, each=nrow(z)))^2)) # all radius from the center pixel to the contour pixels
        mz <- z[which.min(abs(radius - median(radius))),] # the coordinate of contour pixels with the median radius (or closest to the median)
        # The coordinates of all along the line to the maximum line: this is arranged such that it's always from the center to the periphery
        lz <- bresenham(c(cz[1], mz[1]), c(cz[2], mz[2]))
        radial_gradient <- NULL
        for (k in 1:length(lz$x)) radial_gradient[k] <- ref@.Data[lz$x[k], lz$y[k]]

        transection[[j]] <- tibble(x = lz$x, y = lz$y, Intensity = radial_gradient)
    }

    return(transection)
}
draw_pixels <- function (img, pixel.x, pixel.y) {
    #' This function takes an image and draw red on the assigned pixels
    stopifnot(length(pixel.x) == length(pixel.y))

    # Render the gray-scale image back into color mode
    img <- abind(img, img, img, along = 3) %>% Image(colormode = "Color")

    # Create a logical mask
    m <- Image(T, dim(img)[1:2])
    for (i in 1:length(pixel.x)) m[pixel.x[i], pixel.y[i]] <- F
    M <- abind(m, m, m, along = 3)

    # Combine with solid colored image, replace appropriate pixels in image
    mask <- Image("red", dim = dim(img)[1:2], colormode = "Color")
    ans <- img * M + mask * !M

    return(ans)
}
```



```{r}
image_name <- list_images$image_name[i]
image_rolled <- readImage(paste0(list_images$folder_green_rolled[i], image_name, ".tiff"))
load(paste0(list_images$folder_green_watershed_file[i], image_name, ".RData")) # this should contain one R object image_watershed2

transection <- extract_transection(image_watershed2, image_rolled) %>%
    lapply(function(x) mutate(x, DistanceToCenter = 1:length(x))) %>%
    bind_rows(.id = "ObjectID")

# Save the transection image
image_transect <- draw_pixels(image_rolled, transection$x, transection$y)
writeImage(image_transect, paste0(folder_main, "example/", image_name, "-07-transection.tiff"))
display(image_transect, method = "raster")

```


Plot two pairs's transection for example

```{r}
"read two transection data (in tansect folder and csv) and plot it "

read_csv(paste0(folder_main, ))

# transections
#
# i = 5
# transection <- transections[[i]]
#
# # plot two isolates
#
# bind_rows(mutate(transections[[4]], Group = "isolate1"),
#           mutate(transections[[5]], Group = "isolate2"),
#           mutate(transections[[6]], Group = "pair")
# ) %>%
#     ggplot() +
#     geom_line(aes(x = DistanceToCenter, y = Intensity, group = interaction(Group, ObjectID), color = Group), lwd = .3) +
#     #geom_point(data = transections[[1]], aes(x = DistanceToCenter, y = Intensity, group = ObjectID)) +
#     theme_classic() +
#     #guides(color = "none") +
#     labs()



```



# Output the example

```{r}
# # writeImage(image_original, paste0(folder_main, "example/", image_name, "-00-original.tiff"))
# # writeImage(image_green, paste0(folder_main, "example/", image_name, "-01-green.tiff"))
# writeImage(image_rolled, paste0(folder_main, "example/", image_name, "-02-rolled.tiff"))
# writeImage(image_thresholded, paste0(folder_main, "example/", image_name, "-03-threshold.tiff"))
# #writeImage(colorLabels(image_object), paste0(folder_main, "example/", image_name, "-03a-object.tiff"))
# writeImage(image_round, paste0(folder_main, "example/", image_name, "-04-round_object.tiff"))
# writeImage(normalize(image_distancemap), paste0(folder_main, "example/", image_name, "-05-distance_map.tiff"))
# writeImage(colorLabels(image_watershed), paste0(folder_main, "example/", image_name, "-06-watershed.tiff"))
```












